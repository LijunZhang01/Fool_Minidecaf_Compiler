# 编译原理试点班报告
|姓名|张利军|学号|2019303032|
|----|-----|---------|----------|

[TOC]













### 实现的基础框架介绍

#### 文法
SYSY文法，详细文法定义参考[比赛定义](https://gitlab.eduxiji.net/nscscc/compiler2021/-/blob/master/SysY%E8%AF%AD%E8%A8%80%E5%AE%9A%E4%B9%89.pdf)
#### 中间IR
三元式
#### 目标语言
RISC-V (跟曾老师有提前说过)![image-20220706144339013](../images/image-20220706144339013.png)
#### 总体设计（参考自[清华](https://decaf-lang.github.io/minidecaf-tutorial/))

![image-20220706164344755](../images/image-20220706164344755.png)

### 实现的功能
#### Minidecaf 指导书实现的功能

![image-20220706162622137](../images/image-20220706162622137.png)

#### 为满足sysy文法增加的功能

![image-20220706162919078](../images/image-20220706162919078.png)

#### 侧例通过情况展示

100/103

![image-20220706163351851](../images/image-20220706163351851.png)

### 优化介绍
#### 数据流图的建立

##### 基本块

基本块是指一段这样的代码序列：

1. 除出口语句外基本块中不含任何的 Branch、Beqz（条件为假时跳转）、Bnez（条件为真时跳转）或者 Return 等跳转语句（但可以包含 Call 语句）。
2. 除入口语句外基本块中不含任何的 Label 标记，即不能跳转到基本块中间。
3. 在满足前两条的前提下含有最多的连续语句，即基本块的头尾再纳入一条语句将会违反上面两条规则。

下面的例子中，代码中不同的基本块被标以不同的颜色：

![img](https://decaf-lang.github.io/minidecaf-tutorial/docs/step7/pics/dataflow.png)

也就是说，基本块内的代码执行过程总是从基本块入口开始，到基本块出口结束的，中间不会跳到别的地方或者从别的地方跳进来。

#####  控制流图

控制流图是一个有向图：它以基本块作为结点，如果一个基本块 A 执行完之后，有可能跳转到另一个基本块 B，则图中包含从 A 对应结点到 B 对应结点的有向边。对于以 Branch 语句或者任何非跳转语句结尾的基本块，其后继只有一个结点；对于以 CondBranch 语句结尾的基本块，其后继含有两个结点，分别对应跳转条件为真和假的情况。不难想像，控制流图的有向边组成的每一个环路都对应着程序中的一个循环结构。由于该图给出程序控制流的各种可能执行路径，因此也称为控制流图。

为进行编译优化，建立控制流图是必不可少的一步。已知一个操作序列，如何根据这个操作序列建立对应的控制流图呢？通常分为两步进行：

1. 划分基本块。
2. 建立基本块之间的连接关系。

基本块的划分算法比较简单：从头到尾扫描操作序列，当遇到以下情况时结束当前基本块，并开始一个新的基本块建立过程：

1. 当遇到一个 Label 标记而且存在跳转语句跳转到这个行号时。
2. 当遇到 Branch、CondBranch 或者 Return 等跳转语句时。

整个操作序列扫描完毕后，我们就成功建立了所有基本块。

在划分好基本块之后，需要从头到尾依次扫描所有的基本块建立控制流图：

1. 如果当前基本块以 Branch 结尾，则在当前基本块与所跳转到的目标基本块之间加入一条有向边。
2. 如果当前基本块以 CondBranch 结尾，则在当前基本块和跳转条件成立与不成立的目标基本块之间分别加入一条有向边（共 2 条边）。
3. 如果当前基本块以 Return 结尾，则不需要加入新的边。

在所有的基本块都扫描完毕后，即建立了控制流图。基于控制流图，可以进行控制流分析。

上面例子对应的控制流图如下：

![img](https://decaf-lang.github.io/minidecaf-tutorial/docs/step7/pics/flowgraph.png)

#### 活跃性变量分析

从编译器中端出来的中间代码中，我们对 TAC 中使用的临时变量的个数并没有做任何限制。但是在实际机器中，物理寄存器的数量是有限的。

因此我们需要想办法把这些无限多的临时变量“塞”到有限个物理寄存器里面：如果两个临时变量不会在同一条指令中被用到，那么我们可以让这两个临时变量使用同一个物理寄存器（把一部分当前指令用不到的临时变量保存到栈上）。

根据这样的原则，大多数的临时变量都可以用有限的几个物理寄存器对应起来，而“塞不下”的那些临时变量，则可以暂时保存到内存里面（因为访问内存的时间比访问寄存器的时间多得多，因此临时变量应尽可能一直存放在物理寄存器中，尽量不要 spill 到栈上）。

由于一个物理寄存器在确定的时刻只能容纳一个临时变量，因此为了把若干个变量塞到同一个物理寄存器里面，我们需要知道各个临时变量分别在哪条指令以后不会再被用到（以便腾出当前临时变量占用的物理寄存器给别的临时变量）。此时我们需要用到活性分析（liveness analysis），或者称为“活跃变量分析”。

一个临时变量在某个执行点是活的（也叫“活跃”、live），是指该临时变量在该执行点处具有的值会在这个执行点以后被用到，换句话说，就是在该执行点到给这个临时变量重新赋值的执行点之间存在着使用到这个临时变量的语句。活性分析是指分析每一个临时变量在程序的每一个执行点处的活跃情况，通常是通过计算出每个执行点处的活跃变量集合来完成。

下面代码中每行语句右边都给出了执行完该语句后的活跃变量集合：

| TAC 代码          | 活跃变量集合    |
| ----------------- | --------------- |
| `_T0 = 4`         | {_T0}           |
| `_T1 = 3`         | {_T0, _T1}      |
| `_T2 = _T0 * _T1` | {_T0}           |
| `_T3 = _T0 * _T0` | {_T0, _T3}      |
| `_T2 = _T3 * _T3` | {_T0, _T2, _T3} |
| `_T2 = _T0 * _T2` | {_T2, _T3}      |
| `_T1 = _T2 * _T3` | {_T1}           |
| `return _T1`      | 空集            |

一般来说，活性分析是通过求解活跃变量方程来完成的。为了介绍活跃变量方程的概念， 我们需要先引入下面四种针对基本块的集合：

1. Def 集合：一个基本块的 Def 集合是在这个基本块内被定值的所有变量。所谓的定值 （definition），可以理解为给变量赋值，例如加法语句给目标变量定值等（注意：Store 语句不给任何变量定值，Load 语句则会给对应变量定值）。
2. LiveUse 集合：一个基本块的 LiveUse 集合是在这个基本块中所有在定值前就被引用过的变量，包括了在这个基本块中被引用到但是没有被定值的那些变量。
3. LiveIn 集合：在进入基本块入口之前必须是活跃的那些变量。
4. LiveOut 集合：在离开基本块出口的时候是活跃的那些变量。

其中 Def 和 LiveUse 是基本块本身的属性，对每个基本块从后往前遍历基本块内的指令便可以求出。

有了基本块的这四个集合的概念，我们给出控制流图中每个基本块满足的活跃变量方程:

![img](https://decaf-lang.github.io/minidecaf-tutorial/docs/step7/pics/formula.png)

该方程说的是一个基本块的 LiveOut 集合是其所有后继基本块的 LiveIn 集合的并集，而且 LiveIn 集合是 LiveUse 集合的变量加上 LiveOut 集合中去掉 Def 集合以后的部分。

这个方程的直观意义是：

1. 一个基本块的任何一个后继基本块入口处活跃的变量在这个基本块的出口必须也是活跃的。
2. 在一个基本块入口处需要活跃的变量是在该基本块中没有定值就被使用的变量，以及在基本块出口处活跃但是基本块中没有定值过的变量（因为它们的初值必定是在进入基本 块之前就要具有的了）。

根据这个方程，我们可以通过迭代更新的办法求出每个基本块的 LiveIn、LiveOut 集合，以下是求解的伪代码：

```
for i <- 1 to N do compute Def[B_i] and LiveUse[B_i]; 
for i <- 1 to N do LiveIn[B_i] <- phi ; 
changed <- true; 
while (changed) do { 
    changed <- false; 
    for i <- N downto 1 do {   
        LiveOut[B_i] <- Union (LiveIn[s]) where s belongs to succ(B_i) ;
        NewLiveIn <- Union (LiveUse[B_i], (LiveOut[B_i] – Def[B_i])); 
        if (LiveIn[B_i] != NewLiveIn) then {     
            changed <- true;     
            LiveIn[B_i] <- NewLiveIn;   
        }    
    } 
}
```

获得了每个基本块的 LiveIn 和 LiveOut 集合以后，我们需要进一步地计算基本块内每个 TAC 语句的 LiveIn 和 LiveOut 集合。如果我们把基本块内所有 TAC 语句分别看成是一个独立的基本块，则不难想像，前面提到的活跃变量方程仍然有效，不同之处在于，一个基本块对应的 “控制流图” 有以下三种特点：

1. 每个节点的出度都是 1，也就是说 LiveOut(B) = LiveIn(Succ(B))。
2. 由于每个结点只含有一个语句，因此其 Def 集要么是空集，要么只含有一个元素。
3. 由于每个结点对应的语句里所引用的所有变量在使用的时候都未在该基本块中经过定值，其 LiveUse 集合就是源操作数对应的所有变量。

基于上面三个特点，已经求出基本块的 LiveOut 集合的前提下我们只需要在每个基本块内从后往前遍历基本块内的指令就可以对每条基本块内指令求出 LiveIn、LiveOut。

#### 死代码消除

死代码移除指移除执行后不会产生实际作用的代码，这里使用活跃变量分析的方法 来实现。活跃变量的计算依赖于后向流，对于基本块来说，有如下数据流方程

![image-20220706155318180](../images/image-20220706155318180.png)

这个数据流方程的解法使用课上介绍的迭代算法即可，解之前需要遍历所有基本块以 得到 𝐷𝑒𝑓 以及 𝐿𝑖𝑣𝑒𝑈𝑠𝑒 集合。这里的 𝐿𝑖𝑣𝑒𝑈𝑠𝑒 集合是 B 中定值前被引用的变量集合，而 𝐷𝑒𝑓 集合是基本块 B 中被定值的所有变量的集合，显然它是课上介绍的 𝐷𝑒𝑓 集合的超集， 其多出的元素是 B 中被引用后又被定值的变量，显然它们也在 𝐿𝑖𝑣𝑒𝑈𝑠𝑒 中，因此不影响数 据流方程的计算。对于每个基本块，正序遍历所有的指令，将定值变量加入 𝐷𝑒𝑓，被引用 变量若不在 𝐷𝑒𝑓 中，加入 𝐿𝑖𝑣𝑒𝑈𝑠𝑒 即可。框架中的 LivenessAnalyzer 实现了后向流方 程的求解，可以直接调用。 解出数据流方程后，利用基本块的 𝐿𝑖𝑣𝑒𝑂𝑢𝑡 集合可以计算出每个指令语句的 𝐿𝑖𝑣𝑒𝑂𝑢𝑡 集合，这里的计算需要从基本块中反向遍历指令，将当前 𝐿𝑖𝑣𝑒𝑂𝑢𝑡 附加到当前指令上，从 中移除在当前指令定值的变量，并加入当前指令引用的变量，然后传递给前一条指令即可。 之后可以进行死代码的消除。从比较粗略的角度来说，Tac 中“没有既没有副作用，同 时也没有赋值目标的语句”，因为 Tac 中可以没有赋值目标的指令只有分支跳转、函数调 用、传参，通常分支和函数调用均被认为有副作用。对于有赋值目标、非函数调用的指令如果赋值目标不在当前指令的 𝐿𝑖𝑣𝑒𝑂𝑢𝑡 中，则可以直接移除；如果是函数调用，则应将返 回值赋值部分优化掉，如 _T1 = call _T2 变为 call _T2。 值得一提的是，虽然函数调用会改变栈帧等，具有副作用，但从程序的 context 来说， 某些函数调用前后并没有产生实际影响，如返回值未被使用的类构造函数、Alloc 函数实际 上是没有作用的，但仅依赖 Tac 源码是无法获取这些信息的。因此实现时在 TacInstr 中 加入了一个 hint 成员变量，用于指示该 Tac 指令的类型，如 CONSTRUCTOR 或是 ALLOC， 这些信息在 PA3 的 Tac 代码生成时可以获取到。基于数据流分析的死代码移除结束后，可 能会残留这类函数调用，之后进行一遍窥孔优化就可以将它们删除。另外，注意到 Tac 语 言的虚拟寄存器与实际汇编的区别，可以发现 Tac 中 Callee 使用虚拟寄存器并不会影响 Caller 的同名寄存器，而汇编中 Caller 调用 Callee 前显然需要保存一些 caller-saved 寄存 器从而保证调用约定的实现，因此一个没有 store 指令，也不调用 print, alloc 等，而 仅仅在虚拟寄存器上进行各种操作的函数，如果其返回值不被使用，它也是没有实际副作 用的，这种函数调用不会对 context 产生影响，在更为 aggressive 的优化中同样可以被移除 （这里没有实现）。 另外，PA3 范式化的处理会生成一些不可达代码，如 if (_T2 == 0) branch _L9 return _T0 branch _L10 _L9: return _T1 _L10: ... 显然 branch _L10 这里产生了一个不可达的基本块。可以通过对 CFG 从入口节点进 行一遍 BFS，剩下不可达的节点全部移除即可。因为被删除的代码在控制流中本身是不可 达的，这个优化只有减小生成代码体积的作用。

#### 控制流优化

1.消除不可能到达的代码

​	实现起来比较简单，只要遍历一遍，看每个块的出度和入度即可。

2.消除空的 END-BY-JUMP 块

​	如果某一个块是以jump结尾的，如果没有合适的跳转，可消除。

#### 常量优化

为了简化，只实现了整数的常量传播。很显然，常量传播也需要借助正向数据流，相应 集合实际上是寄存器值列表，每个寄存器可以取三种值 CONST, UNDEF, NAC，分别代表常量，未定义，变量，且为常量时还会保存相应的值。另外，与前面的正向数据流方程不同， 这里的并集、差集、交集等运算均与传统的集合运算不同，定义如下：

![image-20220706160122418](../images/image-20220706160122418.png)

𝐴 与 𝐵 都是寄存器值列表，𝐴𝑖 和 𝐵𝑖 代表同一寄存器在两个列表中的不同取值，上述的合 并操作和是符合直观感觉的，比如其中一个寄存器值未定义时，合并结果依赖于另一个寄 存器的值。

 另外，迭代算法也需要加以改动，每轮迭代时，𝐼𝑛 集合按照上述定义的交集运算计算 即可，但这里基本块级别的 𝐺𝑒𝑛 和 𝐾𝑖𝑙𝑙 并不好定义，难以直接通过集合运算得到 𝑂𝑢𝑡，不 过可以正向遍历基本块内的指令，从而将 𝐼𝑛 集合转换为 𝑂𝑢𝑡 集合。主要有以下几种情况 

1. 对于形如 𝑧 = 𝑥 ⊕ 𝑦 这样的 Binary 指令，若两操作数为常量，直接计算得到结果，置 寄存器 𝑧 的值为常量；若其中一个操作数为变量，则 𝑧 的值为变量，否则 𝑧 未定义。 对于 Unary 同理

2.  对于 LoadImm，直接将目的寄存器置为常量 

3. 对于 Assign，目的寄存器的值与源寄存器一致 

4. 对于 Load, Call，目的寄存器为 Nac，表示该值是变量

5. 对于 LoadStr, LoadVtbl，因为没有实现它们的常量推导，置目标寄存器为 Undef 

   其中置为常量的操作类似于 𝐺𝑒𝑛，置为 Undef 类似于 𝐾𝑖𝑙𝑙，显然这里的操作是比前 面几种优化方法要复杂的。迭代算法结束后，得到每个基本块的 𝐼𝑛 集合，可以用类似的 方法得到每个指令的 𝐼𝑛 集合，从而可以根据寄存器值的情况对指令进行修改，如 Binary 指令的两个操作数均为常量时，可以替换为 LoadImm 对应表达式的值，如果一个操作数为 常量，可以实现算术恒等式优化，如 𝑥 + 0, 𝑥 ∗ 1 这类操作均可以替换为 Assign，而 𝑥 && 0, 𝑥 || 1, 𝑥 ∗ 0 这种有确定值的则可以变为 LoadImm；对于 CondBranch，如果条件 为常量，可以将其转换为普通 Branch，且可能产生一些不可达块，从而可以进一步优化。

    经过常量传播后，一些寄存器可能变得不活跃，可以通过死代码消除进行优化。可以 看到，复写传递、常量传播、公共表达式提取均可能产生死代码，因此实现时先做这三种优 化，之后做一次死代码消除，最后做一次窥孔优化，由此作为一轮 pass，总体上进行三轮， 完成最终的优化。

#### 窥孔优化（强度削弱）

这里我没做特别的工作，只是特殊处理了以下几种情况：

1.将“mv a0,a0”这种直接去掉。因为没啥作用。

2.将“add a0,0”去掉。

3.将“mul a0,1”去掉。

#### 图着色寄存器分配

我们知道，对于任意一个基本块，我们都有：
$$
\begin{equation}
\label{equation:liveness}
LiveIn[B]=LiveUse[B]\cup(LiveOut[B]-Def[B]) \\
LiveOut[B]=\bigcup_{b\in S[B]}(LiveIn)
\end{equation}
$$
而类似地，我们也可以对基本块中的 TAC 语句 $t$ 递归地定义 $LiveOut[t]$。设某个给定基本块 $B$ 的 TAC 语句按照顺序排列为 $t_1, t_2, \dots, t_n$，且其中任意一句 $t_i$ 可表示为 $v_{i0}:=f_i(v_{i1}, v_{i2},\dots,v_{im_i})$，其中 $v_{i0}$ 是被定值的变量（可以为空），后面 $m_i$ 个是被引用的变量。则我们有：
$$
\begin{equation}
LiveOut[t_i]:=
\begin{cases}
(LiveOut[t_{i+1}]\cup\{v_{(i+1)1}, v_{(i+1)2},\dots,v_{(i+1)m_{i+1}})\} \backslash \{v_{(i+1)0}\} & (i \leq n-1) \\
LiveOut[B] & (i=n)
\end{cases}
\end{equation}
$$
考虑到 $LiveOut$ 表示在执行该语句后依旧活跃（会被用到）的变量，并且基本块中的语句都是顺序执行的，上述的定义显然是合理的。这也与框架中现有的实现是一致的。

在对于一个基本块 $B$ 建立相干图时，我们将结点集合定义为：
$$
Nodes[B]=LiveUse[B] \cup \bigcup_{i=1}^n \{v_{ij}:0\leq j \leq m_i, v_{ij}\neq\text{null}\}
$$
边集合定义为：
$$
Edges[B]=ColoredLiveUse[B]\cup \bigcup_{i=1}^n \{(v_{i0}, v'):v'\in LiveOut[t_i],~v_{i0}\neq v',~v_{i0}, v'\in Nodes[B]\}
$$
其中 $ColoredLiveUse[B]$ 表示将 $LiveUse[B]$ 对应的结点两两相连，使得这些变量不能保存在同一个（虚拟）寄存器中。而后面的部分即代表了连边准则：

> for each procedure a register-interference graph is constructed in which the nodes are symbolic registers and an edge connects two nodes if one is live at a point where the other is defined.

这里的 `live` 就表示在某个语句后还会被用到的变量，它们与该语句定值的变量显然不能保存在同一寄存器中，因此需要连接一条边，代表它们不能拥有相同的颜色。由于只需要针对 $B$ 进行计算，定义中我们忽略了 $LiveOut[t_i]$ 中不属于 $B$ 中的变量。

在代码的实现上，在对每一个基本块实现上述的相干图建立过程，并调用框架完成着色和寄存器分配后，我们还需要在每个基本块生成代码前（即最开始处）插入语句，将 $LiveOut[B]$ 中对应的变量都加载到分配后的（虚拟）寄存器中，以供下面的语句使用。

完整算法

上述算法只是一个简化版本，如果需要完整版本的干涉图染色寄存器分配算法，还需要如下修改：

首先需要修改染色算法，即`InferenceGraph` 类中的 `color()` 函数。如果无法找到邻居少于 $k$ 的节点（即寄存器不够用时），使用启发式算法，删去一个节点（即产生一个 spill）后继续，直到能够完成算法。伪代码为：

```java
boolean color() {
    n <- node with degress < number of registers
    if (n != null) {
        remove(n)
        subColor = color()
        n.reg = chooseReg(n)
        return subColor
    } else {
		removeRandomNode()
        color()
        return true
    }
}
```

而后需要修改寄存器分配，处理上面产生的 spill，

* `getRegForRead` 函数中，如果某个变量没有关联寄存器（`t.reg == -1），就寻找一个（该语句不涉及的）寄存器 $r$，在语句生成代码前，把 $r$ 的值保存到内存中，并把 $t$ 的值加载到 $r$ 中。而后在语句的代码后，从内存中恢复 $r$ 寄存器的原有值。

* `getRegForWrite` 函数中，如果某个变量没有关联寄存器（`t.reg == -1），可直接把对应 $t$ 的值写入到内存中。

  我为了方便，直接用了一个A5,A6这两个寄存器，因为我看侧例里面么有超过那么多的函数传递，所以就直接使用了，也能提高一下速度。

事实上，除了能对基本块能够实现这一算法，也可对整个函数体进行实现。这样，能够消除进入和退出基本块时的寄存器保存/恢复的开销，也有全局的数据流信息，可以更高效地使用寄存器。

#### 优化效果对比

我自己写了一个脚本来查看不同情况下生成的汇编行数，进行了对比（我的汇编行数输出之间有换行，所以直接和别的生成对比不准确），效果如下，可以真真切切看到我的优化是起了作用的。

![image-20220706161259738](../images/image-20220706161259738.png)

### 实验总结
#### github提交记录截图

因为我在服务器上写的代码，上传gitlab需要内网才能上传（听说有外网ip?),所以我的提交都是在github上的人，gitlab上没有上传记录，这里贴出我的提交部分截图。完整记录可看我的[github](https://github.com/LijunZhang01/Fool_Minidecaf_Compiler/)

![image-20220706144002038](../images/image-20220706144002038.png)

![image-20220706144032568](../images/image-20220706144032568.png)

#### 启发和收获
**1.**通过本次编译器的实现，我对整个编译器的流程有了非常深刻的认识和理解，从前端，到中间IR，最后到汇编，我每一步都自己实现了（前端使用了flex和bison),完整的走完了整个流程。
**2.**这个项目在我本科阶段也是非常大的一个工程项目，代码量超过了五千行，花费了好长时间，但是通过这次代码的编写，对我自己的代码能力有了非常大的提高，特别是对C++的掌握和理解有了进一步的提高。
**3.**通过本次实际的进行侧例，我也试试在在的体会到了编译当中优化的重要性，你代码的简洁度，对指令翻译的准确度和简洁性，都会实实在在的影响你最后翻译出的汇编指令的多少，再进一步，越高级的优化，越能产生更好的效果，虽然自己做的优化方法比较低级（中级？），但也是加深了我的理解。
**4.**对于数据流图的理解进一步加深了，学习理论是没有深刻理解，通过代码的编写，我对数据流图的掌握和理解，更上一次楼，进一步提高了自己。

### 参考文献
[1]https://decaf-lang.github.io/minidecaf-tutorial/
[2]https://mashplant.gitbook.io/decaf-doc/pa4/shi-yan-nei-rong
[3]https://pku-minic.github.io/online-doc/#/lv1-main/structure
[4]Iterated Register Coalescing(图着色)